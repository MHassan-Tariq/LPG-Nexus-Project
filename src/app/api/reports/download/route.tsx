import { NextRequest, NextResponse } from "next/server";
import { Buffer } from "node:buffer";
import { Document, Page, Text, View, StyleSheet, Image, renderToStream } from "@react-pdf/renderer";
import { parseISO, format } from "date-fns";
import { getCurrentUser } from "@/lib/jwt";
import { prisma } from "@/lib/prisma";
// Core utilities
import { createErrorResponse } from "@/core/api/api-errors";

const styles = StyleSheet.create({
  section: {
    marginBottom: 16,
    marginTop: 12,
  },
  table: {
    width: "100%",
    marginTop: 8,
  },
  tableRow: {
    flexDirection: "row",
    borderBottomWidth: 1,
    borderBottomColor: "#e2e8f0",
    paddingVertical: 8,
  },
  tableHeader: {
    flexDirection: "row",
    borderBottomWidth: 2,
    borderBottomColor: "#1f2933",
    paddingBottom: 8,
    marginBottom: 4,
    fontWeight: 600,
  },
  tableCell: {
    flex: 1,
    paddingHorizontal: 8,
    fontSize: 11,
  },
  tableCellHeader: {
    flex: 1,
    paddingHorizontal: 8,
    fontSize: 11,
    fontWeight: 600,
  },
  label: {
    fontWeight: 600,
    fontSize: 14,
    marginBottom: 8,
  },
  summaryItem: {
    marginBottom: 6,
    fontSize: 12,
  },
});

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const formatParam = searchParams.get("format") || "pdf";
    const startDateParam = searchParams.get("startDate");
    const endDateParam = searchParams.get("endDate");

    if (!startDateParam || !endDateParam) {
      return createErrorResponse("Start date and end date are required", 400);
    }

    // Fetch the reports data using the shared function
    const { getReportsData } = await import("../get-reports-data");
    const data = await getReportsData(startDateParam, endDateParam);

    // Validate data structure
    if (!data || !data.summary || !data.detailedReports) {
      console.error("Invalid data structure:", data);
      throw new Error("Invalid reports data structure");
    }

    if (formatParam === "csv") {
      // Generate CSV
      const csvRows = [
        ["Reports & Analytics"],
        [`Date Range: ${startDateParam} to ${endDateParam}`],
        [""],
        ["Summary"],
        ["Total Revenue", `Rs ${data.summary.totalRevenue.toLocaleString()}`],
        ["Total Expenses", `Rs ${data.summary.totalExpenses.toLocaleString()}`],
        ["Cylinders Delivered", data.summary.cylindersDelivered.toString()],
        ["Net Profit", `Rs ${data.summary.netProfit.toLocaleString()}`],
        [""],
        ["Detailed Reports"],
        ["Category", "Count", "Revenue/Amount", "Growth %"],
        ...data.detailedReports.map((row: any) => [
          row.category,
          row.count.toString(),
          `Rs ${row.revenue.toLocaleString()}`,
          `${row.growth >= 0 ? "+" : ""}${row.growth.toFixed(1)}%`,
        ]),
      ];

      const csvContent = csvRows.map((row) => row.map((cell) => `"${cell}"`).join(",")).join("\n");
      const csvBuffer = Buffer.from(csvContent, "utf-8");

      return new NextResponse(csvBuffer, {
        headers: {
          "Content-Type": "text/csv; charset=utf-8",
          "Content-Disposition": `attachment; filename="reports-${startDateParam}-${endDateParam}.csv"`,
        },
      });
    } else {
      // Fetch saved report design
      const currentUser = await getCurrentUser();
      let reportDesign = null;
      
      if (currentUser) {
        const user = await prisma.user.findUnique({
          where: { id: currentUser.userId },
          select: { reportTemplateDesign: true },
        });
        reportDesign = user?.reportTemplateDesign as any;
      }

      // Get header and footer config from saved design or use defaults
      const headerConfig = reportDesign?.headerConfig || {
        showHeader: true,
        showLogo: false,
        logo: null,
        logoPosition: "left",
        logoSize: "medium",
        showBusinessName: true,
        showAddress: true,
        showContactInfo: true,
        showTaxInfo: false,
        businessName: "LPG Nexus Distribution",
        address: "123 Business Street, City, State 12345",
        phoneNumber: "+91 9876543210",
        email: "info@lpgnexus.com",
        ntnGst: "",
        fontSize: 14,
        fontWeight: "regular",
        textColor: "#000000",
        lineHeight: 1.5,
        textAlignment: "left",
        headerLayout: "horizontal",
        showDivider: true,
        dividerStyle: "solid",
        dividerColor: "#e2e8f0",
        dividerThickness: 1,
        topMargin: 0,
        bottomMargin: 20,
      };

      const footerConfig = reportDesign?.footerConfig || {
        showFooter: true,
        footerLeftText: "Generated by LPG Nexus",
        footerCenterText: "",
        footerRightText: "",
        showPageNumber: true,
        showPrintedDate: true,
        showSignatureLine: false,
        fontSize: 12,
        textColor: "#666666",
        alignment: "center",
        signatureLabel: "Authorized Signature",
        showSignature: false,
        signatureAlignment: "center",
        signatureLineSpacing: 8,
        topMargin: 20,
        bottomMargin: 0,
      };

      // Logo size mapping
      const logoSizeMap: Record<string, number> = {
        small: 40,
        medium: 60,
        large: 80,
      };
      const logoSize = logoSizeMap[headerConfig.logoSize as string] || 60;

      // Font weight mapping
      const fontWeightMap: Record<string, string> = {
        regular: "400",
        medium: "500",
        bold: "700",
      };

      // Divider style mapping
      const dividerStyleMap: Record<string, "solid" | "dotted" | "dashed"> = {
        solid: "solid",
        dotted: "dotted",
        dashed: "dashed",
      };

      // Get logo URL - handle base64 data URLs and regular URLs
      let logoUrl: string | null = null;
      if (headerConfig.showLogo && headerConfig.logo) {
        if (typeof headerConfig.logo === 'string') {
          // Base64 data URL (starts with data:image/)
          if (headerConfig.logo.startsWith('data:')) {
            logoUrl = headerConfig.logo;
          }
          // HTTP/HTTPS URL
          else if (headerConfig.logo.startsWith('http://') || headerConfig.logo.startsWith('https://')) {
            logoUrl = headerConfig.logo;
          }
          // Relative path - construct absolute URL
          else if (headerConfig.logo.startsWith('/')) {
            const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
            logoUrl = `${baseUrl}${headerConfig.logo}`;
          }
        }
      }

      // Dynamic styles based on design
      const dynamicStyles = StyleSheet.create({
        page: {
          padding: 32,
          fontSize: 12,
          fontFamily: "Helvetica",
          color: "#1f2933",
        },
        headerSection: {
          marginBottom: headerConfig.showDivider ? 16 : 12,
        },
        headerContent: {
          flexDirection: headerConfig.headerLayout === "horizontal" ? "row" : "column",
          alignItems: headerConfig.textAlignment === "center" ? "center" : headerConfig.textAlignment === "right" ? "flex-end" : "flex-start",
          gap: 8,
          marginBottom: headerConfig.showDivider ? 8 : 0,
        },
        logo: {
          width: logoSize,
          height: logoSize,
        },
        businessInfo: {
          fontSize: headerConfig.fontSize,
          fontWeight: fontWeightMap[headerConfig.fontWeight] || "400",
          color: headerConfig.textColor,
          lineHeight: headerConfig.lineHeight,
          textAlign: headerConfig.textAlignment === "center" ? "center" : headerConfig.textAlignment === "right" ? "right" : "left",
        },
        businessName: {
          fontSize: headerConfig.fontSize,
          fontWeight: "700",
          marginBottom: 4,
        },
        divider: {
          borderTopWidth: headerConfig.dividerThickness,
          borderTopStyle: dividerStyleMap[headerConfig.dividerStyle] || "solid",
          borderTopColor: headerConfig.dividerColor,
          marginTop: 8,
        },
        footerSection: {
          marginTop: footerConfig.topMargin || 20,
          marginBottom: footerConfig.bottomMargin || 0,
          paddingTop: 16,
          borderTopWidth: 1,
          borderTopColor: "#e2e8f0",
          fontSize: footerConfig.fontSize,
          color: footerConfig.textColor,
        },
        footerRow: {
          flexDirection: "row",
          justifyContent: footerConfig.alignment === "center" ? "center" : footerConfig.alignment === "right" ? "flex-end" : "flex-start",
          flexWrap: "wrap",
          gap: 8,
          textAlign: footerConfig.alignment === "center" ? "center" : footerConfig.alignment === "right" ? "right" : "left",
        },
        signatureSection: {
          marginTop: 16,
          paddingTop: 12,
          borderTopWidth: 1,
          borderTopColor: "#e2e8f0",
          textAlign: footerConfig.signatureAlignment === "center" ? "center" : footerConfig.signatureAlignment === "right" ? "right" : "left",
        },
        signatureLabel: {
          fontSize: footerConfig.fontSize,
          marginBottom: footerConfig.signatureLineSpacing,
        },
        signatureLine: {
          borderBottomWidth: 2,
          borderBottomColor: "#94a3b8",
          width: 120,
        },
      });

      // Helper function to render header
      const renderHeader = () => (
        headerConfig.showHeader !== false && ((headerConfig.showLogo && logoUrl) || headerConfig.showBusinessName || headerConfig.showAddress || headerConfig.showContactInfo) ? (
          <View style={[dynamicStyles.headerSection, { position: 'absolute', top: 0, left: 32, right: 32 }]} fixed>
            <View style={dynamicStyles.headerContent}>
              {/* Logo */}
              {headerConfig.showLogo && logoUrl && (
                <Image
                  src={logoUrl}
                  style={dynamicStyles.logo}
                />
              )}

              {/* Business Info */}
              <View>
                {headerConfig.showBusinessName && headerConfig.businessName && String(headerConfig.businessName).trim() !== '' && (
                  <Text style={[dynamicStyles.businessInfo, dynamicStyles.businessName]}>
                    {String(headerConfig.businessName)}
                  </Text>
                )}
                {headerConfig.showAddress && headerConfig.address && String(headerConfig.address).trim() !== '' && (
                  <Text style={dynamicStyles.businessInfo}>
                    {String(headerConfig.address)}
                  </Text>
                )}
                {headerConfig.showContactInfo && (
                  <Text style={dynamicStyles.businessInfo}>
                    {headerConfig.phoneNumber && String(headerConfig.phoneNumber).trim() !== '' ? String(headerConfig.phoneNumber) : ''}
                    {headerConfig.phoneNumber && headerConfig.email && String(headerConfig.email).trim() !== '' ? " • " : ""}
                    {headerConfig.email && String(headerConfig.email).trim() !== '' ? String(headerConfig.email) : ""}
                  </Text>
                )}
                {headerConfig.showTaxInfo && headerConfig.ntnGst && String(headerConfig.ntnGst).trim() !== '' && (
                  <Text style={dynamicStyles.businessInfo}>
                    NTN/GST: {String(headerConfig.ntnGst)}
                  </Text>
                )}
              </View>
            </View>

            {/* Divider */}
            {headerConfig.showDivider && (
              <View style={dynamicStyles.divider} />
            )}
          </View>
        ) : null
      );

      // Helper function to render footer
      const renderFooter = (pageNumber: number, totalPages: number = 1) => (
        footerConfig.showFooter !== false ? (
        <View style={[dynamicStyles.footerSection, { position: 'absolute', bottom: 32 + (footerConfig.bottomMargin || 0), left: 32, right: 32 }]} fixed>
          <View style={dynamicStyles.footerRow}>
            {footerConfig.footerLeftText && String(footerConfig.footerLeftText).trim() !== '' && (
              <Text>{String(footerConfig.footerLeftText)}</Text>
            )}
            {footerConfig.footerCenterText && String(footerConfig.footerCenterText).trim() !== '' && (
              <Text>{String(footerConfig.footerCenterText)}</Text>
            )}
            <Text>
              {footerConfig.footerRightText && String(footerConfig.footerRightText).trim() !== '' ? String(footerConfig.footerRightText) : ""}
              {footerConfig.showPageNumber && (footerConfig.footerRightText ? " • " : "") + `Page ${pageNumber}`}
              {footerConfig.showPrintedDate && " • " + format(new Date(), "dd MMM yyyy")}
            </Text>
          </View>

          {/* Signature */}
          {(footerConfig.showSignatureLine || footerConfig.showSignature) && (
            <View style={dynamicStyles.signatureSection}>
              {footerConfig.signatureLabel && String(footerConfig.signatureLabel).trim() !== '' && (
                <Text style={dynamicStyles.signatureLabel}>
                  {String(footerConfig.signatureLabel)}
                </Text>
              )}
              <View style={[
                dynamicStyles.signatureLine,
                footerConfig.signatureAlignment === "center" ? { alignSelf: "center" } : 
                footerConfig.signatureAlignment === "right" ? { alignSelf: "flex-end" } : 
                { alignSelf: "flex-start" }
              ]} />
            </View>
          )}
        </View>
        ) : null
      );

      // Calculate approximate header height for content padding (only if header is shown)
      const headerHeight = headerConfig.showHeader !== false 
        ? ((headerConfig.showLogo && logoUrl ? logoSize : 0) + 
           (headerConfig.showBusinessName ? headerConfig.fontSize * 1.5 : 0) +
           (headerConfig.showAddress ? headerConfig.fontSize * 1.5 : 0) +
           (headerConfig.showContactInfo ? headerConfig.fontSize * 1.5 : 0) +
           (headerConfig.showDivider ? 10 : 0) + 
           (headerConfig.topMargin || 0) +
           (headerConfig.bottomMargin || 20) + 40)
        : (headerConfig.topMargin || 0);

      // Calculate approximate footer height (only if footer is shown)
      const footerHeight = footerConfig.showFooter !== false 
        ? (80 + (footerConfig.topMargin || 20) + (footerConfig.bottomMargin || 0))
        : (footerConfig.bottomMargin || 0);

      // Generate PDF using @react-pdf/renderer
      const document = (
        <Document>
          <Page 
            size="A4" 
            style={dynamicStyles.page}
          >
            {/* HEADER SECTION - Fixed on every page */}
            {renderHeader()}

            {/* REPORT BODY */}
            <View style={styles.section}>
              <Text style={styles.label}>Summary</Text>
              <Text style={styles.summaryItem}>Total Revenue: Rs {data.summary.totalRevenue.toLocaleString()}</Text>
              <Text style={styles.summaryItem}>Total Expenses: Rs {data.summary.totalExpenses.toLocaleString()}</Text>
              <Text style={styles.summaryItem}>Cylinders Delivered: {data.summary.cylindersDelivered.toLocaleString()}</Text>
              <Text style={styles.summaryItem}>Net Profit: Rs {data.summary.netProfit.toLocaleString()}</Text>
            </View>

            <View style={styles.section}>
              <Text style={styles.label}>Revenue vs Expenses (Monthly)</Text>
              <View style={styles.table}>
                <View style={styles.tableHeader}>
                  <Text style={styles.tableCellHeader}>Month</Text>
                  <Text style={styles.tableCellHeader}>Revenue</Text>
                  <Text style={styles.tableCellHeader}>Expenses</Text>
                  <Text style={styles.tableCellHeader}>Net</Text>
                </View>
                {data.charts.revenueExpenses.map((row: any, index: number) => {
                  const net = row.payments - row.expenses;
                  return (
                    <View key={index} style={styles.tableRow}>
                      <Text style={styles.tableCell}>{row.month}</Text>
                      <Text style={styles.tableCell}>Rs {row.payments.toLocaleString()}</Text>
                      <Text style={styles.tableCell}>Rs {row.expenses.toLocaleString()}</Text>
                      <Text style={styles.tableCell}>Rs {net.toLocaleString()}</Text>
                    </View>
                  );
                })}
              </View>
            </View>

            <View style={styles.section}>
              <Text style={styles.label}>Cylinder Usage Trend</Text>
              <View style={styles.table}>
                <View style={styles.tableHeader}>
                  <Text style={styles.tableCellHeader}>Month</Text>
                  <Text style={styles.tableCellHeader}>Cylinders Issued</Text>
                </View>
                {data.charts.usageTrend.map((row: any, index: number) => (
                  <View key={index} style={styles.tableRow}>
                    <Text style={styles.tableCell}>{row.month}</Text>
                    <Text style={styles.tableCell}>{row.cylinders.toLocaleString()}</Text>
                  </View>
                ))}
              </View>
            </View>

            <View style={styles.section}>
              <Text style={styles.label}>Cylinder Type Distribution</Text>
              <View style={styles.table}>
                <View style={styles.tableHeader}>
                  <Text style={styles.tableCellHeader}>Type</Text>
                  <Text style={styles.tableCellHeader}>Count</Text>
                  <Text style={styles.tableCellHeader}>Percentage</Text>
                </View>
                {data.charts.cylinderDistribution.map((row: any, index: number) => (
                  <View key={index} style={styles.tableRow}>
                    <Text style={styles.tableCell}>{row.label}</Text>
                    <Text style={styles.tableCell}>{row.value.toLocaleString()}</Text>
                    <Text style={styles.tableCell}>{row.percentage}%</Text>
                  </View>
                ))}
              </View>
            </View>

            <View style={styles.section}>
              <Text style={styles.label}>Detailed Reports</Text>
              <View style={styles.table}>
                <View style={styles.tableHeader}>
                  <Text style={styles.tableCellHeader}>Category</Text>
                  <Text style={styles.tableCellHeader}>Count</Text>
                  <Text style={styles.tableCellHeader}>Revenue/Amount</Text>
                  <Text style={styles.tableCellHeader}>Growth %</Text>
                </View>
                {data.detailedReports.map((row: any, index: number) => (
                  <View key={index} style={styles.tableRow}>
                    <Text style={styles.tableCell}>{row.category}</Text>
                    <Text style={styles.tableCell}>{row.count.toLocaleString()}</Text>
                    <Text style={styles.tableCell}>Rs {typeof row.revenue === 'number' ? row.revenue.toLocaleString() : String(row.revenue)}</Text>
                    <Text style={styles.tableCell}>
                      {row.growth >= 0 ? "+" : ""}
                      {typeof row.growth === 'number' ? row.growth.toFixed(1) : String(row.growth)}%
                    </Text>
                  </View>
                ))}
              </View>
            </View>

            {/* FOOTER SECTION - Fixed on every page */}
            {renderFooter(1)}
          </Page>
        </Document>
      );

      try {
      const stream = await renderToStream(document);
      const chunks: Uint8Array[] = [];

      for await (const chunk of stream) {
        chunks.push(typeof chunk === "string" ? Buffer.from(chunk, "utf-8") : chunk);
      }

      const buffer = Buffer.concat(chunks);

        if (buffer.length === 0) {
          throw new Error("Generated PDF is empty");
        }

      return new NextResponse(buffer, {
        headers: {
          "Content-Type": "application/pdf",
          "Content-Disposition": `attachment; filename="reports-${startDateParam}-${endDateParam}.pdf"`,
          "Content-Length": buffer.length.toString(),
        },
      });
      } catch (pdfError) {
        console.error("Error rendering PDF:", pdfError);
        const pdfErrorMessage = pdfError instanceof Error ? pdfError.message : String(pdfError);
        console.error("PDF Error details:", pdfErrorMessage, pdfError);
        throw new Error(`PDF generation failed: ${pdfErrorMessage}`);
      }
    }
  } catch (error) {
    console.error("Error generating report:", error);
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json(
      { error: "Failed to generate report", details: errorMessage },
      { status: 500 },
    );
  }
}
