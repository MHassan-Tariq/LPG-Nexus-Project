"use server";

import { revalidatePath } from "next/cache";
import { format } from "date-fns";

import { prisma } from "@/lib/prisma";
import { issueOtp, verifyOtp } from "@/lib/otp";
import { sendFactoryResetOtpEmail } from "@/lib/mail";
import { getTenantIdForCreate } from "@/lib/tenant-utils";
import { getTenantFilter } from "@/core/tenant/tenant-queries";

export async function generateBackup() {
  try {
    // Fetch ALL data from ALL database tables independently
    const [
      customers,
      cylinders,
      cylinderTransactions,
      cylinderEntries,
      expenses,
      bills,
      payments,
      paymentLogs,
      inventoryItems,
      dailyNotes,
      users,
      otps,
      systemSettings,
    ] = await Promise.all([
      prisma.customer.findMany(),
      prisma.cylinder.findMany(),
      prisma.cylinderTransaction.findMany(),
      prisma.cylinderEntry.findMany(),
      prisma.expense.findMany(),
      prisma.bill.findMany(),
      prisma.payment.findMany(),
      prisma.paymentLog.findMany(),
      prisma.inventoryItem.findMany(),
      prisma.dailyNote.findMany(),
      prisma.user.findMany(),
      prisma.otp.findMany(),
      prisma.systemSettings.findMany(),
    ]);

    // Create backup object
    const backupData = {
      version: "1.0",
      backupDate: new Date().toISOString(),
      data: {
        customers,
        cylinders,
        cylinderTransactions,
        cylinderEntries,
        expenses,
        bills,
        payments,
        paymentLogs,
        inventoryItems,
        dailyNotes,
        users,
        otps,
        systemSettings,
      },
    };

    // Generate filename with timestamp
    const timestamp = format(new Date(), "yyyy-MM-dd-HH-mm");
    const fileName = `backup-${timestamp}.json`;

    // Save backup record
    const jsonString = JSON.stringify(backupData, null, 2);
    const adminId = await getTenantIdForCreate();
    const backupRecord = await prisma.backup.create({
      data: {
        fileName,
        fileSize: jsonString.length,
        backupDate: new Date(),
        isAutomatic: false,
        adminId,
      },
    });

    revalidatePath("/backup");

    return {
      success: true,
      data: jsonString,
      fileName,
      backupId: backupRecord.id,
    };
  } catch (error) {
    console.error("Backup generation error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to generate backup",
    };
  }
}

export async function restoreBackup(jsonData: string, fileName: string) {
  try {
    const currentAdminId = await getTenantIdForCreate();

    // Validate that we have data
    if (!jsonData || jsonData.trim().length === 0) {
      throw new Error("Backup file is empty. Please select a valid backup file.");
    }

    // Validate JSON format
    let backupData;
    try {
      backupData = JSON.parse(jsonData);
    } catch (parseError) {
      console.error("JSON parse error:", parseError);
      throw new Error(
        "Invalid JSON format. Please ensure the backup file is a valid JSON file. " +
        "Error: " + (parseError instanceof Error ? parseError.message : "Unknown error")
      );
    }

    // Validate that we have an object
    if (!backupData || typeof backupData !== "object") {
      throw new Error(
        "Invalid backup file format: file does not contain a valid JSON object. " +
        "Please ensure this is a backup file generated by this system."
      );
    }

    // Check if it's the new format with 'data' property
    let data;
    if (backupData.data && typeof backupData.data === "object") {
      // New format: { version, backupDate, data: {...} }
      data = backupData.data;
    } else if (
      backupData.customers || 
      backupData.cylinders || 
      backupData.bills ||
      backupData.expenses ||
      backupData.payments ||
      backupData.users
    ) {
      // Legacy format: data is at root level
      data = backupData;
    } else {
      // Provide detailed error message
      const keys = Object.keys(backupData);
      throw new Error(
        `Invalid backup file format: missing 'data' property or backup content. ` +
        `Found keys in file: ${keys.length > 0 ? keys.join(", ") : "none"}. ` +
        `Please ensure this is a backup file generated by this system (version 1.0).`
      );
    }

    // Validate that we have some actual data to restore
    if (!data || typeof data !== "object") {
      throw new Error(
        "Invalid backup file format: data structure is invalid. " +
        "Please ensure this is a backup file generated by this system."
      );
    }

    // Delete all existing data first (outside transaction for speed)
    await prisma.dailyNote.deleteMany();
    await prisma.paymentLog.deleteMany();
    await prisma.payment.deleteMany();
    await prisma.bill.deleteMany();
    await prisma.expense.deleteMany();
    await prisma.cylinderEntry.deleteMany();
    await prisma.cylinderTransaction.deleteMany();
    await prisma.inventoryItem.deleteMany();
    await prisma.cylinder.deleteMany();
    await prisma.customer.deleteMany();
    await prisma.user.deleteMany();
    await prisma.otp.deleteMany();
    await prisma.systemSettings.deleteMany();

    // Helper function to process in batches
    const processBatch = async <T>(
      items: T[],
      batchSize: number,
      processor: (batch: T[]) => Promise<void>
    ) => {
      for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        await processor(batch);
      }
    };

    // Restore users first (no dependencies) - use createMany for better performance
    if (data.users && Array.isArray(data.users) && data.users.length > 0) {
      await processBatch(data.users, 100, async (batch) => {
        await prisma.user.createMany({
          data: batch.map((user: any) => ({
            id: user.id,
            name: user.name,
            email: user.email,
            phone: user.phone ?? null,
            role: user.role ?? "admin",
            username: user.username ?? null,
            department: user.department ?? null,
            profileImage: user.profileImage ?? null,
            companyDescription: user.companyDescription ?? null,
            streetAddress: user.streetAddress ?? null,
            city: user.city ?? null,
            stateProvince: user.stateProvince ?? null,
            country: user.country ?? null,
            passwordHash: user.passwordHash ?? null,
            businessName: user.businessName ?? null,
            createdAt: user.createdAt ? new Date(user.createdAt) : new Date(),
            updatedAt: user.updatedAt ? new Date(user.updatedAt) : new Date(),
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore customers - handle customerCode explicitly
    if (data.customers && Array.isArray(data.customers) && data.customers.length > 0) {
      let maxCustomerCode = 0;

      await processBatch(data.customers, 100, async (batch) => {
        await prisma.customer.createMany({
          data: batch.map((customer: any) => {
            if (customer.customerCode && customer.customerCode > maxCustomerCode) {
              maxCustomerCode = customer.customerCode;
            }
            return {
              id: customer.id,
              customerCode: customer.customerCode,
              name: customer.name,
              contactNumber: customer.contactNumber,
              email: customer.email ?? null,
              customerType: customer.customerType,
              cylinderType: customer.cylinderType,
              billType: customer.billType,
              securityDeposit: customer.securityDeposit ?? null,
              area: customer.area ?? null,
              city: customer.city ?? null,
              country: customer.country ?? null,
              notes: customer.notes ?? null,
              additionalContacts: customer.additionalContacts ?? null,
              status: customer.status ?? "ACTIVE",
              address: customer.address ?? null,
              createdAt: customer.createdAt ? new Date(customer.createdAt) : new Date(),
              updatedAt: customer.updatedAt ? new Date(customer.updatedAt) : new Date(),
              adminId: customer.adminId || currentAdminId,
            };
          }),
          skipDuplicates: true,
        });
      });

      // Reset the sequence
      if (maxCustomerCode > 0) {
        try {
          await prisma.$executeRawUnsafe(
            `SELECT setval(pg_get_serial_sequence('"Customer"', 'customerCode'), ${maxCustomerCode}, true)`,
          );
        } catch (seqError) {
          console.warn("Could not reset customerCode sequence:", seqError);
        }
      }
    }

    // Restore cylinders
    if (data.cylinders && Array.isArray(data.cylinders)) {
      await processBatch(data.cylinders, 100, async (batch) => {
        await prisma.cylinder.createMany({
          data: batch.map((cylinder: any) => ({
            id: cylinder.id,
            serialNumber: cylinder.serialNumber,
            gasType: cylinder.gasType,
            capacityLiters: cylinder.capacityLiters,
            status: cylinder.status,
            location: cylinder.location,
            pressurePsi: cylinder.pressurePsi ?? null,
            lastInspection: cylinder.lastInspection ? new Date(cylinder.lastInspection) : null,
            nextInspection: cylinder.nextInspection ? new Date(cylinder.nextInspection) : null,
            notes: cylinder.notes ?? null,
            customerId: cylinder.customerId ?? null,
            createdAt: cylinder.createdAt ? new Date(cylinder.createdAt) : new Date(),
            updatedAt: cylinder.updatedAt ? new Date(cylinder.updatedAt) : new Date(),
            adminId: cylinder.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore cylinder transactions
    if (data.cylinderTransactions && Array.isArray(data.cylinderTransactions)) {
      await processBatch(data.cylinderTransactions, 100, async (batch) => {
        await prisma.cylinderTransaction.createMany({
          data: batch.map((transaction: any) => ({
            id: transaction.id,
            type: transaction.type,
            quantity: transaction.quantity,
            recordedAt: transaction.recordedAt ? new Date(transaction.recordedAt) : new Date(),
            dueDate: transaction.dueDate ? new Date(transaction.dueDate) : null,
            notes: transaction.notes ?? null,
            cylinderId: transaction.cylinderId ?? null,
            customerId: transaction.customerId ?? null,
            userId: transaction.userId ?? null,
            createdAt: transaction.createdAt ? new Date(transaction.createdAt) : new Date(),
            adminId: transaction.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore cylinder entries
    if (data.cylinderEntries && Array.isArray(data.cylinderEntries)) {
      await processBatch(data.cylinderEntries, 100, async (batch) => {
        await prisma.cylinderEntry.createMany({
          data: batch.map((entry: any) => ({
            id: entry.id,
            billCreatedBy: entry.billCreatedBy,
            cylinderType: entry.cylinderType,
            cylinderLabel: entry.cylinderLabel ?? null,
            deliveredBy: entry.deliveredBy ?? null,
            quantity: entry.quantity,
            unitPrice: entry.unitPrice,
            amount: entry.amount,
            customerName: entry.customerName,
            customerId: entry.customerId ?? null,
            verified: entry.verified ?? false,
            description: entry.description ?? null,
            deliveryDate: entry.deliveryDate ? new Date(entry.deliveryDate) : new Date(),
            createdAt: entry.createdAt ? new Date(entry.createdAt) : new Date(),
            adminId: entry.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore expenses
    if (data.expenses && Array.isArray(data.expenses)) {
      await processBatch(data.expenses, 100, async (batch) => {
        await prisma.expense.createMany({
          data: batch.map((expense: any) => ({
            id: expense.id,
            expenseType: expense.expenseType || expense.category || "OTHER",
            category: expense.category || "OTHER",
            description: expense.description ?? null,
            amount: expense.amount,
            expenseDate: expense.expenseDate || expense.date ? new Date(expense.expenseDate || expense.date) : new Date(),
            createdAt: expense.createdAt ? new Date(expense.createdAt) : new Date(),
            updatedAt: expense.updatedAt ? new Date(expense.updatedAt) : new Date(),
            adminId: expense.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore bills
    if (data.bills && Array.isArray(data.bills)) {
      await processBatch(data.bills, 100, async (batch) => {
        await prisma.bill.createMany({
          data: batch.map((bill: any) => ({
            id: bill.id,
            customerId: bill.customerId,
            billStartDate: bill.billStartDate ? new Date(bill.billStartDate) : new Date(),
            billEndDate: bill.billEndDate ? new Date(bill.billEndDate) : new Date(),
            lastMonthRemaining: bill.lastMonthRemaining ?? 0,
            currentMonthBill: bill.currentMonthBill ?? 0,
            cylinders: bill.cylinders ?? 0,
            status: bill.status ?? "PENDING",
            createdAt: bill.createdAt ? new Date(bill.createdAt) : new Date(),
            updatedAt: bill.updatedAt ? new Date(bill.updatedAt) : new Date(),
            adminId: bill.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore payments
    if (data.payments && Array.isArray(data.payments)) {
      await processBatch(data.payments, 100, async (batch) => {
        await prisma.payment.createMany({
          data: batch.map((payment: any) => ({
            id: payment.id,
            billId: payment.billId,
            amount: payment.amount,
            paidOn: payment.paidOn ? new Date(payment.paidOn) : new Date(),
            method: payment.method ?? "bank_transfer",
            notes: payment.notes ?? null,
            createdAt: payment.createdAt ? new Date(payment.createdAt) : new Date(),
            adminId: payment.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore payment logs
    if (data.paymentLogs && Array.isArray(data.paymentLogs)) {
      await processBatch(data.paymentLogs, 100, async (batch) => {
        await prisma.paymentLog.createMany({
          data: batch.map((log: any) => ({
            id: log.id,
            billId: log.billId ?? null,
            paymentId: log.paymentId ?? null,
            customerName: log.customerName || "",
            customerCode: log.customerCode ?? null,
            eventType: log.eventType,
            amount: log.amount ?? null,
            details: log.details ?? null,
            billStartDate: log.billStartDate ? new Date(log.billStartDate) : null,
            billEndDate: log.billEndDate ? new Date(log.billEndDate) : null,
            performedAt: log.performedAt ? new Date(log.performedAt) : new Date(),
            createdAt: log.createdAt ? new Date(log.createdAt) : new Date(),
            adminId: log.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore inventory items
    if (data.inventoryItems && Array.isArray(data.inventoryItems)) {
      await processBatch(data.inventoryItems, 100, async (batch) => {
        await prisma.inventoryItem.createMany({
          data: batch.map((item: any) => ({
            id: item.id,
            category: item.category || "General",
            cylinderType: item.cylinderType,
            quantity: item.quantity,
            vendor: item.vendor || "",
            receivedBy: item.receivedBy || "",
            description: item.description ?? null,
            verified: item.verified ?? false,
            entryDate: item.entryDate || item.receivedDate ? new Date(item.entryDate || item.receivedDate) : new Date(),
            createdAt: item.createdAt ? new Date(item.createdAt) : new Date(),
            adminId: item.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore daily notes
    if (data.dailyNotes && Array.isArray(data.dailyNotes)) {
      await processBatch(data.dailyNotes, 100, async (batch) => {
        await prisma.dailyNote.createMany({
          data: batch.map((note: any) => ({
            id: note.id,
            noteDate: note.noteDate || note.date ? new Date(note.noteDate || note.date) : new Date(),
            noteText: note.noteText || note.content || "",
            labels: note.labels ?? [],
            sections: note.sections ?? {},
            characterCount: note.characterCount ?? 0,
            createdAt: note.createdAt ? new Date(note.createdAt) : new Date(),
            updatedAt: note.updatedAt ? new Date(note.updatedAt) : new Date(),
            adminId: note.adminId || currentAdminId,
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore OTPs (optional, usually not needed)
    if (data.otps && Array.isArray(data.otps)) {
      await processBatch(data.otps, 100, async (batch) => {
        await prisma.otp.createMany({
          data: batch.map((otp: any) => ({
            id: otp.id,
            email: otp.email,
            code: otp.code,
            expiresAt: otp.expiresAt ? new Date(otp.expiresAt) : new Date(),
            verifiedAt: otp.verifiedAt ? new Date(otp.verifiedAt) : null,
            createdAt: otp.createdAt ? new Date(otp.createdAt) : new Date(),
          })),
          skipDuplicates: true,
        });
      });
    }

    // Restore system settings
    if (data.systemSettings && Array.isArray(data.systemSettings)) {
      await processBatch(data.systemSettings, 100, async (batch) => {
        await prisma.systemSettings.createMany({
          data: batch.map((setting: any) => ({
            id: setting.id,
            key: setting.key,
            value: setting.value ?? "",
            updatedAt: setting.updatedAt ? new Date(setting.updatedAt) : new Date(),
          })),
          skipDuplicates: true,
        });
      });
    }

    // Save restore record
    const adminId = await getTenantIdForCreate();
    await prisma.restore.create({
      data: {
        fileName,
        restoreDate: new Date(),
        adminId,
      },
    });

    revalidatePath("/backup");

    return {
      success: true,
      message: "Backup restored successfully",
    };
  } catch (error) {
    console.error("Restore error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to restore backup",
    };
  }
}

export async function getLastBackup() {
  try {
    const lastBackup = await prisma.backup.findFirst({
      orderBy: {
        backupDate: "desc",
      },
      select: {
        backupDate: true,
        fileName: true,
      },
    });

    return lastBackup
      ? {
          date: lastBackup.backupDate,
          fileName: lastBackup.fileName,
        }
      : null;
  } catch (error) {
    console.error("Error fetching last backup:", error);
    return null;
  }
}

export async function getLastRestore() {
  try {
    const lastRestore = await prisma.restore.findFirst({
      orderBy: {
        restoreDate: "desc",
      },
      select: {
        restoreDate: true,
        fileName: true,
      },
    });

    return lastRestore
      ? {
          date: lastRestore.restoreDate,
          fileName: lastRestore.fileName,
        }
      : null;
  } catch (error) {
    console.error("Error fetching last restore:", error);
    return null;
  }
}

export async function getBackupFolderPath() {
  try {
    const tenantFilter = await getTenantFilter();
    const setting = await prisma.systemSettings.findFirst({
      where: {
        ...tenantFilter,
        key: "backup_folder_path",
      },
    });
    return setting?.value ?? null;
  } catch (error) {
    console.error("Error fetching backup folder path:", error);
    return null;
  }
}

export async function setBackupFolderPath(path: string) {
  try {
    const adminId = await getTenantIdForCreate();
    await prisma.systemSettings.upsert({
      where: {
        adminId_key: {
          adminId: (adminId || null) as any,
          key: "backup_folder_path",
        },
      },
      update: { value: path },
      create: {
        key: "backup_folder_path",
        value: path,
        adminId: adminId || null,
      },
    });
    revalidatePath("/backup");
    return { success: true };
  } catch (error) {
    console.error("Error setting backup folder path:", error);
    return { success: false, error: error instanceof Error ? error.message : "Failed to save folder path" };
  }
}

/**
 * Factory Reset Actions
 */
export async function getAdminEmail() {
  try {
    // Get the first admin user (super admin)
    const admin = await prisma.user.findFirst({
      where: {
        role: "ADMIN",
      },
      orderBy: {
        createdAt: "asc", // Get the oldest admin (likely the super admin)
      },
      select: {
        email: true,
        name: true,
        username: true,
      },
    });

    return admin?.email ?? null;
  } catch (error) {
    console.error("Error fetching admin email:", error);
    return null;
  }
}

export async function getAdminUsername() {
  try {
    // Get the first admin user (super admin)
    const admin = await prisma.user.findFirst({
      where: {
        role: "ADMIN",
      },
      orderBy: {
        createdAt: "asc",
      },
      select: {
        username: true,
      },
    });

    return admin?.username ?? null;
  } catch (error) {
    console.error("Error fetching admin username:", error);
    return null;
  }
}

export async function requestFactoryResetOtp() {
  try {
    const adminEmail = await getAdminEmail();
    
    if (!adminEmail) {
      return {
        success: false,
        error: "No admin user found. Cannot send reset OTP.",
      };
    }

    // Get admin username for email
    const adminUsername = await getAdminUsername();

    // Generate and send OTP
    const { code, expiresAt } = await issueOtp(adminEmail);
    const emailResult = await sendFactoryResetOtpEmail(adminEmail, code, adminUsername);

    if (!emailResult.success) {
      return {
        success: false,
        error: emailResult.error || "Failed to send factory reset OTP. Email service may not be configured.",
      };
    }

    return {
      success: true,
      email: adminEmail,
      expiresAt: expiresAt.toISOString(),
      message: "Factory reset OTP sent to admin email",
    };
  } catch (error) {
    console.error("Error requesting factory reset OTP:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to send reset OTP",
    };
  }
}

export async function performFactoryReset(otpCode: string) {
  try {
    const adminEmail = await getAdminEmail();
    
    if (!adminEmail) {
      return {
        success: false,
        error: "No admin user found. Cannot perform factory reset.",
      };
    }

    // Verify OTP first
    const verificationResult = await verifyOtp(adminEmail, otpCode);

    if (!verificationResult.valid) {
      return {
        success: false,
        error: verificationResult.reason === "expired" 
          ? "OTP has expired. Please request a new one." 
          : "Invalid OTP code. Please try again.",
      };
    }

    // Get the super admin user to preserve it
    const superAdmin = await prisma.user.findFirst({
      where: {
        role: "ADMIN",
      },
      orderBy: {
        createdAt: "asc",
      },
    });

    if (!superAdmin) {
      return {
        success: false,
        error: "Super admin user not found. Cannot perform factory reset.",
      };
    }

    const superAdminId = superAdmin.id;
    const superAdminData = {
      id: superAdmin.id,
      name: superAdmin.name,
      email: superAdmin.email,
      phone: superAdmin.phone,
      role: superAdmin.role,
      username: superAdmin.username,
      department: superAdmin.department,
      profileImage: superAdmin.profileImage,
      companyDescription: superAdmin.companyDescription,
      streetAddress: superAdmin.streetAddress,
      city: superAdmin.city,
      stateProvince: superAdmin.stateProvince,
      country: superAdmin.country,
      passwordHash: superAdmin.passwordHash,
      businessName: superAdmin.businessName,
      createdAt: superAdmin.createdAt,
    };

    // Delete ALL data in a transaction (except super admin)
    await prisma.$transaction(
      async (tx) => {
        // Delete all data in reverse order of dependencies
        await tx.dailyNote.deleteMany();
        await tx.paymentLog.deleteMany();
        await tx.payment.deleteMany();
        await tx.bill.deleteMany();
        await tx.expense.deleteMany();
        await tx.cylinderEntry.deleteMany();
        await tx.cylinderTransaction.deleteMany();
        await tx.inventoryItem.deleteMany();
        await tx.cylinder.deleteMany();
        await tx.customer.deleteMany();
        await tx.backup.deleteMany();
        await tx.restore.deleteMany();
        await tx.otp.deleteMany();
        
        // Delete all users except super admin
        await tx.user.deleteMany({
          where: {
            id: {
              not: superAdminId,
            },
          },
        });

        // Delete most system settings, but keep essential ones if needed
        // You can customize this based on what settings you want to preserve
        await tx.systemSettings.deleteMany({
          where: {
            key: {
              notIn: ["backup_folder_path"], // Keep backup folder path if you want
            },
          },
        });

        // Recreate super admin with original data
        await tx.user.create({
          data: superAdminData,
        });
      },
      {
        maxWait: 300000, // 5 minutes
        timeout: 300000, // 5 minutes
      },
    );

    revalidatePath("/backup");
    revalidatePath("/");

    return {
      success: true,
      message: "Factory reset completed successfully. The system has been restored to a brand-new state.",
    };
  } catch (error) {
    console.error("Factory reset error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to perform factory reset",
    };
  }
}
